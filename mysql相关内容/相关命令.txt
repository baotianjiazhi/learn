连接数据库 mysql -u root -p
创建数据库 create database test；
删除数据库 drop database test；
MySQL中表和列可以改名，datables不能rename 
查看所有库 show databases;
选库 use 数据库名
查看库下面所有表 show tables;
建表create table stu(
		snum id int,
		sname varchar(10)
		)engine myisam charset utf8;//engine是指表引擎和性能
删除表 drop table stu;
修改表名 rename table stu to newstu;
清空表 truncate newstu;
truncate 和 delete的区别在于 truncate相当于删除表后再创建一个全新的表，而delete是从行删除所有行的
层面来操作的
查看表结构 desc class;

#增
	insert操作 往哪张表 添加行 class
	添加哪几列 （id, sname, gender, company, salary, fanbu）
	添加什么值 （1, "张三", "男", "百度", 8888.67, 334）
	set names gbk;
	insert into class
	(id, sname, gender, company, salary, fanbu)
	values
	(1,'张三','f','百度',888.67,334)
	如果不声明插入的列，即顺序插入

#改
	update操作 改哪张表 update class
	改成什么 set gender = 'm'
	改哪几行
	update class
	set gender = 'm',company = 'qiandu'
	where id = 6(wher后跟的是表达式，不一定非要是id);

#删
	删除一行只能整个行一起删除,不能只删一列
	delete from class where salary > 8800;
	delete from class where gender = 'm'

#查
	#*代表所有列，表名后不加where条件，则选所有行
	select * from class
	select sname,company,salary from class where id=6;

#建表
	建表过程就是一个声明字段的过程
	create table 
	MySQL三大列类型

	数值型
	#增加列 alter table class01 add salary int(5) zerofill not null default 0;
		整型
			Tinyint
				占据空间：1个字节，存储范围：-128-127，0-255
				
			Smallint
			Mediuint
			int
			bigint
		浮点型/定点型
			Float(M,D) decimal(M,D)
			M叫"精度"-->代表"总位数",而D是"标度"代表小数位
			float的精度有时会有损失
			如果像银行和账户建议用decimal
		create table class01(
			sname varchar(20) not null default '',
			age tinyint not null default 0,
			snum tinyint(5) zerofill not null default 0)engine myisam charset utf8;
			#建表时不加说明，表示有符号数，想表示无符号数声明unsigned
		
	字符型
		char,varchar,text,blob
		char和varchar分别是定长和变长类型
		char(N),不够N个长度,在字符尾部补空格
		varchar(100),也是存储100个长度，对于vachar型但列内容前有一到两个字节来
		标识该列的内容长度
		#注意char(M),varchar(M)中的M限制的是字符不是字节

	日期类型
		date(mysql中有一个问题:date的默认值不能设为0000-00-00可以在select @@sql_mode查看到
		NO_ZERO_IN_DATE,NO_ZERO_DATE这两个属性, 使用SET GLOBAL sql_mode='其他的属性', 
		去掉这两个属性即可)
		date "0000-00-00"
		time "00:00:00"
		datetime "0000-00-00 00:00:00"

	#建表create
		在开发中,会员的信息优化往往是,使用频率高的表,优先考虑效率,存储到一张表中,不常用的信息和
		比较占据空间的信息,优先考虑空间占用,储存于辅表中
		create table 表名(
			列1声明 列类型 列1参数,
			列2声明 列类型 列2参数,
				···
		）engine myisam/innodb/bdb charset utf8/gbk/latin1
		
		create table member(
			id int unsigned auto_increment primary key,
			username char(20) not null default '',
			gender char(1) not null default '',
			weight tinyint unsigned not null default 0,
			birth date not null default '0000-00-00',
			salary decimal(8, 2) not null default 0,
			lastlogin int unsigned not null default 0
		)engine myisam charset utf8;
		
		#增加列
		alter table 表名 add 列名称 列类型 列参数[加的列在表的最后]
		
		alter table 表名 add 列名称 列类型 列参数 after 列名[把新列加在指定列后]
		
		alter table 表名 add 列名称 列类型 列参数 first [把新列加在最前面]
		
		#删除列
		alter table 表名 drop 列名 
		
		#修改列
		alter table 表名 modify 列名称 列类型 列参数[修改列, Modify不能修改列名]
			#修改列名称
			alter table 表名 change 旧列名 新列名 列类型 列参数
	
	
#查询！！！
	1.基础where的查询:
		1.1查询主键为32的商品(goods_id,goods_name,shop_price)
			select goods_id,goods_name,shop_price from goods where goods_id = 32;
			
		1.2查询不属于第3个栏目的所有商品
			select goods_id,cat_id,goods_name from goods where cats_id != 3;
			
		1.3本店价格大于3000的商品
			select goods_id,cat_id,goods_name,price from goods where price > 3000;
			
		1.4本店价格低于或等于100元的商品
			select goods_id,cat_id,goods_name,shop_price from goods where shop_price <= 100;
			
		1.5取出第4栏目和第19栏目的商品(不许用or)
			select goods_id,cat_id,goods_name,shop_price  from goods where cat_id in (4, 19);
			
		1.6取出100<=本店价格<=500的商品(不许用and)
			select goods_id,cat_id,goods_name,shop_price  from goods where shop_price between 100 and 500;
			
	
		1.7取出不在第3栏目和不在第11栏目的商品(and,或者not in分别实现)
			select goods_id,cat_id,goods_name,shop_price  from goods where cat_id not in (3, 11);
			select goods_id,cat_id,goods_name,shop_price  from goods where cat_id != 3 and cat_id != 11;
			
		1.8取出价格大于100且小于300，或者大于1000且小于3500的商品
			select goods_id,cat_id,goods_name,shop_price  from goods where
			shop_price < 300 and shop_price > 100 or shop_price < 3500 and  shop_price > 1000;
			
		1.9取出第3个栏目下面价格<1000或>3000,并且点击量>5的商品
			select goods_id,cat_id,goods_name,shop_price,click_count  from goods where
			cat_id = 3 and (shop_price < 1000 or shop_price > 3000) and click_count > 5;
			
		1.10取出第1个栏目下面的商品(注意:1栏目下面没有商品,但子栏目下面有)
			
		1.11取出名字以"诺基亚"开头的商品
			 select goods_id,goods_name from goods
			 where goods_name like '诺基亚%';
			 
		1.12取出名字为"诺基亚xx"的手机
			select goods_id,goods_name from goods
			where goods_name like '诺基亚__';
			
		1.13取出名字不以"诺基亚"开头的商品
			select goods_id,goods_name from goods
			where goods_name not like '诺基亚%';
			
		1.14取出第3个栏目下面价格在1000到3000之间,并且点击量>5"诺基亚"开头的商品
			select goods_id,goods_name,cat_id, shop_price, click_count from goods
			where cat_id = 3 and (shop_price between 1000 and 3000) and click_count > 5 and goods_name like '诺基亚%';
		
		#列就是变量,在每一行上,列的值都在变化
		where 条件是表达式,在哪一行上表达式为真,哪一行就取出来
		比如下面的条件,shop_price在不同的行,有不同的值
		在哪一行时,shop_price>5000如果为真就取出该行
		
			有一道面试题如下:
				把num值处于[20, 29]之间的改为20,
				把num值处于[30, 39]之间的改为30
				num
				3
				12
				15
				23
				25
				29
				34
				36
				42
				44
				48
				54
				#update mian set num = (num/10)*10 where num between 20 and 40;
			把goods表中商品为"诺基亚xxx"的商品改为"HTCxxx",提示:substring(),concat()
		
	2.分组查询
		2.1查出最贵的商品价格
			select max(shop_price) from goods;
			
		2.2查出最大(最新)的商品编号
			select max(goods_id) from goods;
			
		2.3查出最便宜的商品的价格
			select min(shop_price) from goods;
			
		2.4查出最旧(最小)的商品编号
			select min(goods_id) from goods; 
			
		2.5查询该店所有商品的库存总量
			select sum(goods_number) from goods;
		
		2.6查询所有商品的平均价格
			select avg(shop_price) from goods;
			
		2.7查询该店一共有多少种商品
			select count(*) from goods;
		
		#select count(*) from 表名 查询绝对的行数,哪怕某一行所有字段全部为Null也计算在内
		而select count(列名) from 表名 查询的是该列不为null的所有行数
		在myisam引擎中两种没有区别,但是在innodb的表中,count(*)直接读取行数,执行效率极低
		
		#group by
			严格讲以group by a,b,c为列,则select的列只能在a,b,c中选择才没有语义上的矛盾
			
		2.8查询每个栏目下面
		最贵商品的价格
		最低商品的价格
		商品的平均价格
		商品的库存量
		商品的种类
		提示:(5个聚合函数,sum,avg,max,min,count与group的综合应用)
		select cat_id,max(shop_price) from goods group by cat_id;
		select cat_id,min(shop_price) from goods group by cat_id;
		select cat_id,avg(shop_price) from goods group by cat_id;
		select cat_id,sum(goods_number) from goods group by cat_id;
		select cat_id,count(*) from goods group by cat_id;
		
		
		#having 想通过自建列查询
	3.having和group综合运用查询：
	3.1查询该店的商品比市场价所节省的价格
		select goods_id,shop_price,goods_number,shop_price*goods_number as hk from goods;
		
	3.2查询每个商品所积压的货款(提示:库存*单价)
		select sum(goods_number*shop_price) from goods group by goods_id;
		
	3.3查询该店积压的总货款
		select sum(goods_number*shop_price) from goods
		
	3.4查询该店每个栏目下积压的总货款
		select sum(goods_number*shop_price) from goods group by cat_id;
		
	3.5查询比市场价省钱200元以上的商品及该商品所省的钱(where和having分别实现)
		select goods_id,shop_price,(market_price-shop_price) as dis from goods having dis > 200;
		
	3.6查询积压货款超过1w元的栏目,以及该栏目积压的货款
		select sum(shop_price*goods_number) as hk from goods group by cat_id having hk > 10000;
		
	3.7:where-having-group综合练习题
	有如下表及数据
	name subject score
	张三 数学	 90
	张三 语文    50
	张三 地理    40
	李四 语文    55
	李四 政治    45
	王五 政治    30
	要求:查询出2门以及2门以上不及格者的平均成绩
	select name,avg(score),sum(score-60<0) as rr from result group by name having rr >= 2;
	问题解析:
		1.首先算出所有人的平均成绩 select name,avg(score) from result group by name;
		2.再计算所有人是否挂科 select name,subject,score,score < 60 as rr from result;
		3.将两者综合起来 select name,avg(score),sum(score<60) as rr from result group by name having rr >= 2;
	
	#order by
		order by要放在where/group/having的后面,即对最后的结果集进行排序,顺序不能乱
		排序的语法:
			order by 结果集中的列名 des/asc
			
			例:order by shop_price desc 按价格降序排列
			order by add_time asc 按添加时间升序排列
			
			先按cat_id排序,再按shop_price排序
			select goods_id,cat_id,goods_name,shop_price
			from goods
			order by cat_id asc,shop_price desc;
	#limit
		limit放在所有语句的最后
		Limit [offset],N
		offset:偏移量---通俗的说就是跳过几行
		N:取出条目的数量
	
	
	#子查询
		查询网店最新的(goods_id最大的)一条商品
			select goods_id from goods order by goods_id desc limit 1;
		查询网店最新的(goods_id最大的)一条商品(不用排序)
			select * from goods where goods_id = (select max(goods_id) from goods limit 1);
		#where型子查询:指把内层查询的结果作为外层查询的比较结果.
			典型题:查询最大商品,最贵商品
			如果 where 列=(内容sql),则内层sql返回必是单行单列,单个值
			如果 where 列 in (内层sql),则内层sql只返回单列,可多行
		#from
			查询每个栏目下goods_id最大的商品
			select max(goods_id),cat_id from (select goods_id,cat_id,goods_name from goods 
			order by cat_id asc,goods_id desc) as tmp  group by cat_id;